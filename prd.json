{
  "project": "Media Janitor",
  "branchName": "main",
  "userStories": [
    {
      "id": "US-48.1",
      "title": "Ultra API Settings - Backend",
      "story": "As a user, I want to configure my Ultra.cc API credentials, so that the app can fetch my storage and traffic stats",
      "acceptanceCriteria": [
        "Add `ultra_api_url` (String, nullable) and `ultra_api_key_encrypted` (String, nullable) columns to UserSettings model",
        "Create Alembic migration for new columns",
        "PATCH `/api/settings` accepts `ultra_api_url` and `ultra_api_key` fields",
        "Ultra API key is encrypted before storage (like Jellyfin/Jellyseerr keys)",
        "GET `/api/settings` returns `ultra_api_configured: bool` (not the actual key)",
        "Typecheck passes",
        "Unit tests pass"
      ],
      "context": "Epic 48: Ultra.cc seedbox monitoring integration. API endpoint: {base_url}/total-stats with Bearer token auth. Response fields: service_stats_info.free_storage_gb, service_stats_info.traffic_available_percentage. Follow existing pattern: encrypt API key like Jellyfin/Jellyseerr keys in UserSettings. Stats cached in DB, fetched during sync (not on page load). NON-GOALS: No Slack/email notifications, no automatic actions, no historical tracking.",
      "priority": 1,
      "passes": true,
      "notes": "Implemented with POST/GET /api/settings/ultra endpoints (follows existing pattern like Radarr/Sonarr)"
    },
    {
      "id": "US-48.3",
      "title": "Ultra Warning Thresholds - Settings",
      "story": "As a user, I want to set my own warning thresholds for storage and traffic, so that I get alerts relevant to my usage patterns",
      "acceptanceCriteria": [
        "Add `ultra_storage_warning_gb` (Integer, default 100) and `ultra_traffic_warning_percent` (Integer, default 20) columns to UserSettings",
        "Create Alembic migration for new columns",
        "PATCH `/api/settings` accepts threshold values",
        "GET `/api/settings` returns current threshold values",
        "Settings page has number inputs for both thresholds in the 'Seedbox Monitoring' section",
        "Inputs show defaults (100 GB, 20%) when not set",
        "Typecheck passes",
        "Unit tests pass",
        "Verify in browser using browser tools"
      ],
      "context": "Epic 48: Ultra.cc seedbox monitoring. This story adds user-configurable warning thresholds. Defaults: 100 GB storage, 20% traffic. Dashboard will use these to show yellow/red warnings. Follow existing UserSettings pattern for new columns. NON-GOALS: No Slack/email notifications, no automatic actions.",
      "priority": 2,
      "passes": true,
      "notes": "Added threshold columns to UserSettings, POST/GET /api/settings/ultra/thresholds endpoints, Seedbox Monitoring section in Settings/Connections with Ultra.cc connection and Warning Thresholds inputs"
    },
    {
      "id": "US-48.4",
      "title": "Fetch Ultra Stats During Sync",
      "story": "As a user, I want my seedbox stats fetched when I sync, so that I always see current storage and traffic info",
      "acceptanceCriteria": [
        "Create `ultra_service.py` with `fetch_ultra_stats(url, api_key)` function",
        "Function calls `{url}/total-stats` with Bearer token authentication",
        "Returns dict with `free_storage_gb` (float) and `traffic_available_percentage` (float), or None if API fails",
        "Add `ultra_free_storage_gb` (Float, nullable), `ultra_traffic_available_percent` (Float, nullable), `ultra_last_synced_at` (DateTime, nullable) columns to UserSettings",
        "Create Alembic migration for new columns",
        "Sync process (`/api/sync`) calls Ultra API if credentials are configured",
        "Stats are stored in UserSettings after successful fetch",
        "Sync succeeds even if Ultra API call fails (non-blocking)",
        "Typecheck passes",
        "Unit tests pass"
      ],
      "context": "Epic 48: Ultra.cc seedbox monitoring. API endpoint: {base_url}/total-stats with Bearer token auth. Response JSON: service_stats_info.free_storage_gb (float), service_stats_info.traffic_available_percentage (float). Create new ultra_service.py following existing service patterns (jellyfin.py, sonarr.py). Stats stored in UserSettings table. Sync must NOT fail if Ultra API is down - log warning and continue. NON-GOALS: No historical tracking.",
      "priority": 3,
      "passes": true,
      "notes": "Added fetch_ultra_stats() to ultra_service.py with full error handling, integrated into run_user_sync() as non-blocking call after Jellyseerr sync, created migration for ultra_free_storage_gb, ultra_traffic_available_percent, ultra_last_synced_at columns"
    },
    {
      "id": "US-49.1",
      "title": "Delete Movies from Cache After Deletion",
      "story": "As a user, I want deleted movies to stay deleted after page refresh, so that I don't see ghost items that are already removed from my library",
      "acceptanceCriteria": [
        "After successful Radarr deletion, delete matching `CachedMediaItem` from database",
        "Match by TMDB ID stored in `raw_data` JSON field (key: `ProviderIds.Tmdb`)",
        "If Radarr deletion succeeds but Jellyseerr fails, still delete from cache",
        "If Radarr deletion fails, do NOT delete from cache",
        "Also delete matching `CachedJellyseerrRequest` if it exists (by TMDB ID)",
        "Typecheck passes",
        "Unit tests pass",
        "Verify in Docker: delete a movie, refresh page, item stays deleted"
      ],
      "context": "Epic 49: Fix deletion cache persistence. Problem: Items reappear after page refresh because cache isn't updated. Endpoint: DELETE /api/content/movie/{tmdb_id}. Match CachedMediaItem by TMDB ID in raw_data JSON (key: ProviderIds.Tmdb). Delete from cache ONLY after successful Radarr deletion. Also delete matching CachedJellyseerrRequest by TMDB ID. NON-GOALS: No undo/restore, no change to sync behavior, keep optimistic UI pattern.",
      "priority": 11,
      "passes": true,
      "notes": "Added _delete_cached_media_by_tmdb_id() and _delete_cached_jellyseerr_request_by_tmdb_id() helper functions to content.py router. Cache deletion happens after successful Radarr deletion but before response."
    },
    {
      "id": "US-49.2",
      "title": "Delete Series from Cache After Deletion",
      "story": "As a user, I want deleted TV series to stay deleted after page refresh, so that I don't see ghost items that are already removed from my library",
      "acceptanceCriteria": [
        "After successful Sonarr deletion, delete matching `CachedMediaItem` from database",
        "Match by TMDB ID stored in `raw_data` JSON field (key: `ProviderIds.Tmdb`)",
        "If Sonarr deletion succeeds but Jellyseerr fails, still delete from cache",
        "If Sonarr deletion fails, do NOT delete from cache",
        "Also delete matching `CachedJellyseerrRequest` if it exists (by TMDB ID)",
        "Typecheck passes",
        "Unit tests pass",
        "Verify in Docker: delete a series, refresh page, item stays deleted"
      ],
      "context": "Epic 49: Fix deletion cache persistence. Same pattern as US-49.1 but for series. Endpoint: DELETE /api/content/series/{tmdb_id}. Match CachedMediaItem by TMDB ID in raw_data JSON (key: ProviderIds.Tmdb). Delete from cache ONLY after successful Sonarr deletion. Also delete matching CachedJellyseerrRequest by TMDB ID. NON-GOALS: No undo/restore, no change to sync behavior.",
      "priority": 12,
      "passes": true,
      "notes": "Added cache deletion to delete_series endpoint using existing _delete_cached_media_by_tmdb_id() and _delete_cached_jellyseerr_request_by_tmdb_id() helpers. Cache deletion happens AFTER successful Sonarr deletion but before response."
    },
    {
      "id": "US-49.3",
      "title": "Delete Requests from Cache After Deletion",
      "story": "As a user, I want deleted Jellyseerr requests to stay deleted after page refresh, so that I don't see ghost requests in the Unavailable Requests tab",
      "acceptanceCriteria": [
        "After successful Jellyseerr media deletion, delete matching `CachedJellyseerrRequest` from database",
        "Match by Jellyseerr ID (existing lookup already works)",
        "Typecheck passes",
        "Unit tests pass",
        "Verify in Docker: delete a request, refresh page, request stays deleted"
      ],
      "context": "Epic 49: Fix deletion cache persistence. Endpoint: DELETE /api/content/request/{jellyseerr_id}. Simpler than movies/series - just delete CachedJellyseerrRequest by Jellyseerr ID after successful API deletion. Existing lookup logic already works. NON-GOALS: No undo/restore.",
      "priority": 13,
      "passes": true,
      "notes": "Added _delete_cached_jellyseerr_request_by_id() helper function. Cache deletion happens AFTER successful Jellyseerr media deletion. If deletion fails, cache is NOT deleted."
    },
    {
      "id": "US-51.1",
      "title": "Fetch Episode Details During Sync",
      "story": "As a user, I want episode air dates to be cached during sync, so that the Recently Available page can detect new episodes without API calls",
      "acceptanceCriteria": [
        "Add `fetch_jellyseerr_season_episodes(client, server_url, api_key, tmdb_id, season_number)` function to `sync.py`",
        "Function calls `GET /api/v1/tv/{tmdb_id}/season/{season_number}` endpoint",
        "Returns list of `{episodeNumber, name, airDate}` dicts",
        "Graceful failure: returns empty list on API error (logged as warning)",
        "In `fetch_jellyseerr_requests()`, for status 4 TV shows, fetch episodes for each partially available season",
        "Store episode data in `raw_data.media.seasons[].episodes` array",
        "Typecheck passes",
        "Unit tests pass"
      ],
      "context": "Epic 51: Recently Available - Show new episodes from ongoing series. Problem: Page doesn't show new episodes from status 4 (partially available) TV shows. Jellyseerr API: GET /api/v1/tv/{tmdb_id}/season/{season_number}. Response has episodes with episodeNumber, name, airDate. Store in raw_data.media.seasons[].episodes (already a JSON field). Reference: original_script.py lines 714-792 (fetch_season_episodes, get_recent_episodes_for_season). NON-GOALS: No individual episode entries, no push notifications.",
      "priority": 14,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-51.2",
      "title": "Include Ongoing Series in Recently Available",
      "story": "As a user, I want to see ongoing series with new episodes in the Recently Available list, so that I know when new episodes of my shows become available",
      "acceptanceCriteria": [
        "Add `_get_recent_episodes_from_cached_data(request, days_back)` helper function in `content.py`",
        "Function checks `raw_data.media.seasons[].episodes[].airDate` for episodes within `days_back` window",
        "Returns `{season_num: [episode_nums]}` dict if recent episodes found, None otherwise",
        "Modify `get_recently_available()` to check for recent episodes on status 4 TV shows",
        "If recent episodes found, use today's date as `availability_date` to force inclusion",
        "Series appears once (not per episode) in the list",
        "Typecheck passes",
        "Unit tests pass"
      ],
      "context": "Epic 51: Recently Available - Show new episodes. Depends on US-51.1 for cached episode data. Status 4 = partially available TV show. Check raw_data.media.seasons[].episodes[].airDate against days_back window. Return dict of {season_num: [episode_nums]} for display. Force inclusion by setting availability_date to today. One entry per series, not per episode. NON-GOALS: No individual episode entries.",
      "priority": 15,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-51.3",
      "title": "API Response with Season/Episode Details",
      "story": "As a frontend developer, I want the Recently Available API to return season and episode information, so that the UI can display episode counts",
      "acceptanceCriteria": [
        "Add optional fields to `RecentlyAvailableItem` model: season_info (str | None), episode_count (int | None), available_episodes (int | None), total_episodes (int | None)",
        "For status 5 TV shows: populate with total seasons and episode count from `raw_data`",
        "For status 4 TV shows: populate with current season progress",
        "Movies return `None` for all these fields",
        "Typecheck passes",
        "Unit tests pass"
      ],
      "context": "Epic 51: Recently Available API enhancement. Add fields to RecentlyAvailableItem model: season_info (e.g., 'Seasons 1-3' or 'Season 4 in progress'), episode_count (total for status 5), available_episodes/total_episodes (for status 4 progress). Status 5 = fully available, Status 4 = partially available. Calculate from raw_data.media.seasons. Movies return None. NON-GOALS: No episode-level details like titles.",
      "priority": 16,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-48.2",
      "title": "Ultra API Settings - Frontend",
      "story": "As a user, I want to enter my Ultra.cc API URL and token in the settings page, so that I can connect my seedbox monitoring",
      "acceptanceCriteria": [
        "Settings page has a new 'Seedbox Monitoring' section with Ultra API URL and API Token fields",
        "Fields are optional (form submits without them)",
        "Shows 'Connected' badge when `ultra_api_configured` is true",
        "Shows masked '••••••••' for token field when already configured",
        "Typecheck passes",
        "Unit tests pass",
        "Verify in browser using browser tools"
      ],
      "context": "Epic 48: Ultra.cc seedbox monitoring frontend. Depends on US-48.1 backend. Add 'Seedbox Monitoring' section to Settings > Connections page (frontend/src/routes/settings/connections/+page.svelte). Follow existing pattern: URL input + API token input. Show 'Connected' badge when ultra_api_configured=true from API. Mask token with '••••••••' when configured. Fields are optional.",
      "priority": 51,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-48.5",
      "title": "Display Ultra Stats on Dashboard",
      "story": "As a user, I want to see my seedbox storage and traffic stats on the dashboard, so that I can monitor my resources at a glance",
      "acceptanceCriteria": [
        "GET `/api/settings` returns `ultra_free_storage_gb`, `ultra_traffic_available_percent`, `ultra_last_synced_at` (if configured)",
        "Dashboard shows 'Seedbox Status' card above issues section (only when Ultra is configured)",
        "Card displays: free storage (GB), traffic available (%)",
        "Card shows last synced timestamp",
        "Storage value turns yellow/warning when below `ultra_storage_warning_gb` threshold",
        "Storage value turns red/danger when below 50% of threshold",
        "Traffic value turns yellow/warning when below `ultra_traffic_warning_percent` threshold",
        "Traffic value turns red/danger when below 50% of threshold",
        "Card is hidden entirely when Ultra API is not configured",
        "Typecheck passes",
        "Unit tests pass",
        "Verify in browser using browser tools"
      ],
      "context": "Epic 48: Ultra.cc dashboard display. Depends on US-48.1/48.3/48.4 for backend data. Add 'Seedbox Status' card to Dashboard (frontend/src/routes/dashboard/+page.svelte) above issues section. Display free_storage_gb, traffic_available_percent, last_synced_at from GET /api/settings. Warning colors: yellow when below threshold, red when below 50% of threshold. Hide card entirely when ultra_api_configured=false. NON-GOALS: No Slack/email notifications.",
      "priority": 52,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-50.1",
      "title": "Update Whitelist Duration Options",
      "story": "As a user, I want shorter whitelist duration options (1 Week, 1 Month), so that I can temporarily whitelist content without long commitments",
      "acceptanceCriteria": [
        "Duration options are: Permanent, 1 Week, 1 Month, 3 Months, 6 Months, Custom Date (in that order)",
        "1 Year option is removed",
        "`DurationOption` type updated to include `1week` and `1month`, remove `1year`",
        "`getExpirationDate()` function handles `1week` (adds 7 days) and `1month` (adds 1 month)",
        "Duration picker displays correctly on Issues page",
        "Duration picker displays correctly on Unavailable page",
        "Existing frontend unit tests updated to reflect new options",
        "Typecheck passes",
        "Unit tests pass",
        "Verify in browser: whitelist an item with 1 Week duration, confirm expiration date is 7 days from now"
      ],
      "context": "Epic 50: Update whitelist duration options. Frontend-only change in frontend/src/routes/issues/+page.svelte. Update durationOptions array to: Permanent, 1 Week, 1 Month, 3 Months, 6 Months, Custom Date. Remove 1 Year. Update DurationOption type: add '1week', '1month', remove '1year'. Update getExpirationDate(): 1week adds 7 days, 1month adds 1 month. No backend changes needed (expires_at is already flexible datetime). NON-GOALS: No additional duration options beyond this set.",
      "priority": 53,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-51.4",
      "title": "Display Episode Details in UI",
      "story": "As a user, I want to see season and episode information on the Recently Available page, so that I understand what content is actually new",
      "acceptanceCriteria": [
        "Add 'Details' column to the table (between Title and Type)",
        "For fully available TV: display 'Seasons 1-3 (30 eps)' format",
        "For partially available TV: display 'S4: 5/12 episodes' format",
        "For movies: display '—' or leave empty",
        "Update the 'Copy' feature to include episode details in the copied text",
        "Responsive: hide Details column on mobile (like Requested By)",
        "Typecheck passes",
        "Unit tests pass",
        "Verify in browser using browser tools"
      ],
      "context": "Epic 51: Recently Available UI enhancement. Depends on US-51.3 for API data. Add 'Details' column to frontend/src/routes/recent/+page.svelte. Use season_info, episode_count, available_episodes, total_episodes from API. Format: fully available shows 'Seasons 1-3 (30 eps)', partial shows 'S4: 5/12 episodes', movies show '—'. Update copy feature to include details. Hide column on mobile (follow Requested By pattern). NON-GOALS: No episode titles/descriptions.",
      "priority": 54,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-52.1",
      "title": "Cache Episode Language Data During Sync",
      "story": "As a user with a Jellyfin server configured, I want the sync process to check language tracks for all TV series episodes, so that series with missing audio tracks are correctly flagged in the Issues page",
      "acceptanceCriteria": [
        "Add `language_check_result` JSON field to `CachedMediaItem` model (structure: `{has_english, has_french, has_french_subs, checked_at}`)",
        "Add `problematic_episodes` JSON field to `CachedMediaItem` model (structure: `[{identifier, name, season, episode, missing_languages}]`)",
        "Create Alembic migration for new fields",
        "Add `check_episode_audio_languages(episode)` helper in `sync.py`",
        "Add `check_series_episodes_languages(client, server_url, api_key, series_id, series_name)` function",
        "Call language checking in `calculate_season_sizes()` loop after size calculation",
        "Add movie language checking in `cache_media_items()` from raw_data MediaSources",
        "Typecheck passes",
        "Unit tests pass"
      ],
      "context": "Epic 52: TV Series Language Detection. ROOT CAUSE: check_audio_languages() in content.py reads MediaSources from Series-level raw_data, but Series metadata doesn't contain episode audio tracks - only individual episodes do. FIX: During sync, fetch all episodes (reuse existing calculate_season_sizes loop) and check each episode's MediaSources for EN/FR audio. Store results in new JSON fields on CachedMediaItem: language_check_result (aggregated series result), problematic_episodes (list of episodes with issues). For movies, check raw_data.MediaSources directly during cache_media_items(). Reference: original_script.py:2124-2250 check_all_episodes_audio_languages(). Language codes: EN = {eng, en, english}, FR = {fre, fr, french, fra}. NON-GOALS: No subtitle-only exemption at episode level.",
      "priority": 17,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-52.2",
      "title": "Use Cached Language Data in Content Service",
      "story": "As a user viewing the Issues page, I want TV series with language issues to appear in the Language tab, so that I can identify and fix series with missing audio tracks",
      "acceptanceCriteria": [
        "Modify `check_audio_languages()` to use cached `language_check_result` field when available",
        "Keep fallback to raw_data parsing for backwards compatibility (movies without cached data)",
        "Add `problematic_episodes` field to `ContentIssueItem` response model",
        "Include problematic episodes data in `/api/content/issues` response for series with language issues",
        "Typecheck passes",
        "Unit tests pass",
        "Verify in Docker: sync, then check `/api/content/issues` returns series with language issues"
      ],
      "context": "Epic 52: TV Series Language Detection. Depends on US-52.1. Update check_audio_languages() in content.py (lines 780-836) to use cached language_check_result field if available, fallback to raw_data parsing for backwards compatibility. Add problematic_episodes field to ContentIssueItem model in models/content.py. In get_content_issues() (content.py:1264-1418), include problematic_episodes in response for series with language issues. This makes TV series with missing audio tracks visible in the Issues page Language tab.",
      "priority": 18,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-52.3",
      "title": "Per-Episode Language Whitelist - Backend",
      "story": "As a user with specific episodes that have intentional language differences, I want to whitelist individual episodes from language checks, so that I don't see false positives for episodes that are meant to have limited audio tracks",
      "acceptanceCriteria": [
        "Create `EpisodeLanguageExempt` model with: `id`, `user_id`, `jellyfin_id` (series ID), `series_name`, `season_number`, `episode_number`, `episode_name`, `created_at`, `expires_at`",
        "Add unique constraint on `(user_id, jellyfin_id, season_number, episode_number)`",
        "Create Alembic migration for new table",
        "Add `add_episode_language_exempt()` service function",
        "Add `get_episode_language_exempt()` service function (list all for user)",
        "Add `remove_episode_language_exempt()` service function",
        "Add `get_episode_exempt_set(db, user_id)` returning set of `(jellyfin_id, season, episode)` tuples",
        "Add API endpoints: GET /api/whitelist/episode-exempt (list all), POST /api/whitelist/episode-exempt (add), DELETE /api/whitelist/episode-exempt/{id} (remove)",
        "Integrate exemption checking into `check_series_episodes_languages()` - skip exempt episodes",
        "Typecheck passes",
        "Unit tests pass"
      ],
      "context": "Epic 52: Per-Episode Whitelisting. Depends on US-52.1. Matches original script's LANGUAGE_CHECK_EPISODE_ALLOWLIST behavior. Create EpisodeLanguageExempt table in database.py following existing whitelist pattern (ContentWhitelist, FrenchOnlyWhitelist, etc.). CRUD functions in content.py: add_episode_language_exempt(), get_episode_language_exempt(), remove_episode_language_exempt(). Helper get_episode_exempt_set() returns set of (jellyfin_id, season, episode) tuples for O(1) lookup during sync. API endpoints in whitelist.py following existing /api/whitelist/{type} pattern. POST body: {jellyfin_id, series_name, season_number, episode_number, episode_name, expires_at?}. Integrate into check_series_episodes_languages() to skip exempt episodes during sync.",
      "priority": 19,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-52.4",
      "title": "Display Problematic Episodes with Whitelist Actions",
      "story": "As a user viewing a TV series with language issues, I want to see which specific episodes have problems and whitelist them individually, so that I can manage language issues at the episode level",
      "acceptanceCriteria": [
        "Update Issues page to show expandable episode list when a series has `problematic_episodes`",
        "Click on series row to expand/collapse episode list",
        "Each episode row shows: identifier (S01E05), name, missing languages (badges)",
        "Each episode row has a 'Whitelist' button with duration picker",
        "Whitelisting calls `POST /api/whitelist/episode-exempt` with episode details",
        "After successful whitelist, remove episode from displayed list (optimistic update)",
        "Show loading state on whitelist button during API call",
        "Show toast notification on success/error",
        "Typecheck passes",
        "Unit tests pass",
        "Verify in browser: expand series, whitelist an episode, episode disappears from list"
      ],
      "context": "Epic 52: Frontend episode display and whitelisting. Depends on US-52.2/52.3. Update frontend/src/routes/issues/+page.svelte. When series has problematic_episodes in API response, make row expandable (click to toggle). Nested list shows each episode: identifier (S01E05 format), name, missing_languages as badges (like existing language issue badges). Each episode row has Whitelist button with duration picker (reuse existing DurationPicker component). POST to /api/whitelist/episode-exempt with: jellyfin_id (series), series_name, season_number, episode_number, episode_name, expires_at. Optimistic update: remove episode from list on success. Toast notifications for success/error.",
      "priority": 55,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-52.5",
      "title": "Episode Exemptions Tab in Whitelist Page",
      "story": "As a user managing my whitelists, I want to see and manage episode-level language exemptions, so that I can review and remove exemptions I no longer need",
      "acceptanceCriteria": [
        "Add 'Episode Exempt' tab to Whitelist page (between 'Language Exempt' and 'Large Content')",
        "Tab displays list of exempted episodes with: series name, episode identifier (S01E05), episode name, expiration status",
        "Each item has a remove button (trash icon)",
        "Remove calls `DELETE /api/whitelist/episode-exempt/{id}`",
        "Show empty state when no exemptions exist",
        "Typecheck passes",
        "Unit tests pass",
        "Verify in browser: view exemptions, remove one, list updates"
      ],
      "context": "Epic 52: Frontend whitelist management. Depends on US-52.3. Update frontend/src/routes/whitelist/+page.svelte. Add 'Episode Exempt' tab to TabType (between 'exempt' and 'large'). Fetch from GET /api/whitelist/episode-exempt. Display: series_name, episode identifier (S{season}E{episode} format), episode_name, expiration status (Permanent or date). Remove button calls DELETE /api/whitelist/episode-exempt/{id}. Follow existing whitelist tab patterns for consistency. Empty state: 'No episode exemptions yet'.",
      "priority": 56,
      "passes": false,
      "notes": ""
    }
  ]
}
